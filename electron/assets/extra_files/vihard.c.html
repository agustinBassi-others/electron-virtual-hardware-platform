<!-- HTML generated using hilite.me -->
<div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%"><span style="color: #008000">/* Copyright 2018, Agustin Bassi.</span>
<span style="color: #008000"> * All rights reserved.</span>
<span style="color: #008000"> *</span>
<span style="color: #008000"> * This file is part of ViHard library, a library of virtual hardware</span>
<span style="color: #008000"> * for Embedded Systems.</span>
<span style="color: #008000"> *</span>
<span style="color: #008000"> * Redistribution and use in source and binary forms, with or without</span>
<span style="color: #008000"> * modification, are permitted provided that the following conditions are met:</span>
<span style="color: #008000"> *</span>
<span style="color: #008000"> * 1. Redistributions of source code must retain the above copyright notice,</span>
<span style="color: #008000"> *    this list of conditions and the following disclaimer.</span>
<span style="color: #008000"> *</span>
<span style="color: #008000"> * 2. Redistributions in binary form must reproduce the above copyright notice,</span>
<span style="color: #008000"> *    this list of conditions and the following disclaimer in the documentation</span>
<span style="color: #008000"> *    and/or other materials provided with the distribution.</span>
<span style="color: #008000"> *</span>
<span style="color: #008000"> * 3. Neither the name of the copyright holder nor the names of its</span>
<span style="color: #008000"> *    contributors may be used to endorse or promote products derived from this</span>
<span style="color: #008000"> *    software without specific prior written permission.</span>
<span style="color: #008000"> *</span>
<span style="color: #008000"> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;</span>
<span style="color: #008000"> * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</span>
<span style="color: #008000"> * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</span>
<span style="color: #008000"> * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE</span>
<span style="color: #008000"> * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR</span>
<span style="color: #008000"> * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF</span>
<span style="color: #008000"> * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS</span>
<span style="color: #008000"> * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN</span>
<span style="color: #008000"> * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)</span>
<span style="color: #008000"> * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE</span>
<span style="color: #008000"> * POSSIBILITY OF SUCH DAMAGE.</span>
<span style="color: #008000"> *</span>
<span style="color: #008000"> */</span>

<span style="color: #008000">/* Date: 2018-10-02 */</span>

<span style="color: #008000">/*==================[inclusions]=============================================*/</span>

<span style="color: #0000ff">#include &quot;vihard.h&quot;</span>

<span style="color: #008000">/*==================[macros and definitions]=================================*/</span>

<span style="color: #0000ff">#define COMMAND_INIT                       &#39;{&#39;</span>
<span style="color: #0000ff">#define COMMAND_END                        &#39;}&#39;</span>
<span style="color: #0000ff">#define COMMAND_SEPARATOR                  &#39;;&#39;</span>

<span style="color: #0000ff">#define MAX_ANALOG_VALUE                   1023</span>

<span style="color: #0000ff">#define MAX_TIME_TO_WAIT_FOR_SERIAL_DATA   1000</span>

<span style="color: #0000ff">#define MS_BETWEEN_COMMANDS                7</span>

<span style="color: #0000ff">#define VH_GPIO_LOW                       &#39;0&#39;</span>
<span style="color: #0000ff">#define VH_GPIO_HIGH                      &#39;1&#39;</span>
<span style="color: #0000ff">#define VH_GPIO_INVALID	                  -1</span>

<span style="color: #008000">/**</span>
<span style="color: #008000"> * Posibles tipos de comandos que se pueden realizar. Este enum es utilizado</span>
<span style="color: #008000"> * unicamente en los comandos de lectura de perifericos virtuales. Cuando el</span>
<span style="color: #008000"> * sistema embebido quiere leer le enviar un REQUEST y la aplicacion responde</span>
<span style="color: #008000"> * con un RESPONSE.</span>
<span style="color: #008000"> */</span>
<span style="color: #0000ff">typedef</span> <span style="color: #0000ff">enum</span> _ViHardCommandType {
    VH_COMM_REQUEST  = <span style="color: #a31515">&#39;0&#39;</span>, <span style="color: #008000">//!&lt; COMM_SERIAL_REQUEST</span>
    VH_COMM_RESPONSE = <span style="color: #a31515">&#39;1&#39;</span>  <span style="color: #008000">//!&lt; COMM_SERIAL_RESPONSE</span>
} ViHardCommandType_t;

<span style="color: #008000">/**</span>
<span style="color: #008000"> * Posibles llamadas a los perifericos virtuales que se pueden realizar.</span>
<span style="color: #008000"> */</span>
<span style="color: #0000ff">typedef</span> <span style="color: #0000ff">enum</span> _ViHardCommand {
    <span style="color: #008000">//Comandos asociados a GPIO</span>
    VH_GPIO_READ        = <span style="color: #a31515">&#39;a&#39;</span>,
    VH_GPIO_WRITE       = <span style="color: #a31515">&#39;b&#39;</span>,
    <span style="color: #008000">//Comandos asociados al ADC/DAC</span>
    VH_ADC_READ         = <span style="color: #a31515">&#39;c&#39;</span>,
    VH_DAC_WRITE        = <span style="color: #a31515">&#39;d&#39;</span>,
    <span style="color: #008000">// Comandos asociados al display LCD</span>
    VH_LCD_WRITE_BYTE   = <span style="color: #a31515">&#39;e&#39;</span>,
    VH_LCD_WRITE_STRING = <span style="color: #a31515">&#39;f&#39;</span>,
    <span style="color: #008000">// Comandos asociados al display LCD</span>
    VH_7SEG_WRITE       = <span style="color: #a31515">&#39;g&#39;</span>,
} ViHardCommand_t;

<span style="color: #008000">/*==================[internal data declaration]==============================*/</span>

<span style="color: #008000">/*==================[internal functions declaration]=========================*/</span>

<span style="color: #0000ff">static</span> <span style="color: #2b91af">void</span>     UartWriteByte       (<span style="color: #2b91af">uint8_t</span> byteToWrite);
<span style="color: #0000ff">static</span> <span style="color: #2b91af">uint8_t</span>  UartReadByte        (<span style="color: #2b91af">void</span>);
<span style="color: #0000ff">static</span> <span style="color: #2b91af">void</span>     UartWriteString     (<span style="color: #2b91af">char</span> * string);
<span style="color: #0000ff">static</span> <span style="color: #2b91af">void</span>     DelayMs             (<span style="color: #2b91af">uint32_t</span> delayMs);
<span style="color: #0000ff">static</span> <span style="color: #2b91af">void</span>     DelayUs             (<span style="color: #2b91af">uint32_t</span> delayMs);
<span style="color: #0000ff">static</span> <span style="color: #2b91af">bool_t</span>   CheckIfValidCommand (ViHardCommand_t comm, ViHardPeriph_t perMap);
<span style="color: #0000ff">static</span> <span style="color: #2b91af">bool_t</span>   AnalogValueToString (<span style="color: #2b91af">uint16_t</span> numToConvert, <span style="color: #2b91af">char</span> * strNumber);
<span style="color: #0000ff">static</span> <span style="color: #2b91af">uint8_t</span>  WaitForSerialData   (<span style="color: #2b91af">char</span> * buffer, <span style="color: #2b91af">uint16_t</span> * timeWaited);
<span style="color: #0000ff">static</span> <span style="color: #2b91af">void</span>     CleanSerialBuffer   (<span style="color: #2b91af">char</span> * buffer, <span style="color: #2b91af">uint32_t</span> size);

<span style="color: #008000">/*==================[internal data definition]===============================*/</span>

<span style="color: #008000">// Cuando se quieren leer datos del puerto serie se debe esperar</span>
<span style="color: #008000">// un tiempo proporcional al baudrate seleccionado. Esta variable</span>
<span style="color: #008000">// estatica se utiliza para este proposito.</span>
<span style="color: #0000ff">static</span> <span style="color: #2b91af">uint32_t</span> UsBetweenReads = 1000000 / VIHARD_BAUDRATE;

<span style="color: #008000">/*==================[external data definition]===============================*/</span>

<span style="color: #008000">/*==================[internal functions definition]==========================*/</span>

<span style="color: #008000">/**</span>
<span style="color: #008000"> * Funcion propia para llamar a la funcion de sacar un</span>
<span style="color: #008000"> * byte por la uart seleccionada cuando se configuro al modulo.</span>
<span style="color: #008000"> * @param byteToWrite byte a escribir en el puerto serie.</span>
<span style="color: #008000"> */</span>
<span style="color: #0000ff">static</span> <span style="color: #2b91af">void</span> UartWriteByte (<span style="color: #2b91af">uint8_t</span> byteToWrite)
{
    UART_WRITE_BYTE(byteToWrite);
}

<span style="color: #008000">/**</span>
<span style="color: #008000"> * Funcion propia para leer un byte del puerto serie.</span>
<span style="color: #008000"> * Como en funciones anteriores, las funciones de este modulo invocan</span>
<span style="color: #008000"> * estas funciones en vez de la de una plataforma en particular. Esto</span>
<span style="color: #008000"> * se realiza de esta manera para darle independencia al codigo para que</span>
<span style="color: #008000"> * pueda ser multiplataforma.</span>
<span style="color: #008000"> * @return el byte leido por la uart.</span>
<span style="color: #008000"> */</span>
<span style="color: #0000ff">static</span> <span style="color: #2b91af">uint8_t</span> UartReadByte (<span style="color: #2b91af">void</span>)
{
    <span style="color: #0000ff">static</span> <span style="color: #2b91af">uint8_t</span> byteReaded;

    <span style="color: #0000ff">if</span> (!UART_READ_BYTE(byteReaded))
    {
        byteReaded = 0;
    }
    DelayUs(UsBetweenReads);

    <span style="color: #0000ff">return</span> byteReaded;
}

<span style="color: #008000">/**</span>
<span style="color: #008000"> * Escribe un string por la uart. En algunas platadormas, esta funcion</span>
<span style="color: #008000"> * es soportada de manera nativa por el framework que brinda acceso al</span>
<span style="color: #008000"> * hardware, en otras plataformas, para mandar un string por la uart es</span>
<span style="color: #008000"> * necesario llamar a la funcion de escribir un byte hasta completar</span>
<span style="color: #008000"> * todos los bytes del string.</span>
<span style="color: #008000"> * @param string puntero al string a enviar por la uart.</span>
<span style="color: #008000"> */</span>
<span style="color: #0000ff">static</span> <span style="color: #2b91af">void</span> UartWriteString (<span style="color: #2b91af">char</span> * string)
{
    <span style="color: #0000ff">while</span> (*string != 0)
    {
        UartWriteByte((<span style="color: #2b91af">uint8_t</span>) * string);
        string++;
    }
}

<span style="color: #008000">/**</span>
<span style="color: #008000"> * Funcion propia para llamar al delay de la plataforma.</span>
<span style="color: #008000"> * @param delayMs</span>
<span style="color: #008000"> */</span>
<span style="color: #0000ff">static</span> <span style="color: #2b91af">void</span> DelayUs (<span style="color: #2b91af">uint32_t</span> microSecs)
{
    <span style="color: #0000ff">volatile</span> <span style="color: #2b91af">uint64_t</span> i;
    <span style="color: #0000ff">volatile</span> <span style="color: #2b91af">uint64_t</span> calculatedDelay;

    calculatedDelay = (CLOCK_SPEED_MHZ * microSecs) / 10;

    <span style="color: #0000ff">for</span>(i = calculatedDelay; i &gt; 0; i--);
}

<span style="color: #008000">/**</span>
<span style="color: #008000"> * Funcion propia para llamar al delay de la plataforma.</span>
<span style="color: #008000"> * @param delayMs</span>
<span style="color: #008000"> */</span>
<span style="color: #0000ff">static</span> <span style="color: #2b91af">void</span> DelayMs (<span style="color: #2b91af">uint32_t</span> delayMs)
{
    DelayUs(delayMs * 1000);
}

<span style="color: #008000">/**</span>
<span style="color: #008000"> * Convierte un numero entero analogico de 10 bits (entre 0 y 1023) en un</span>
<span style="color: #008000"> * string de 4 elementos. El numero siempre sale en formato 4 digitos.</span>
<span style="color: #008000"> *</span>
<span style="color: #008000"> * Ejemplos:</span>
<span style="color: #008000"> *</span>
<span style="color: #008000"> * valor int | valor string</span>
<span style="color: #008000"> * 9         | 0009</span>
<span style="color: #008000"> * 75        | 0075</span>
<span style="color: #008000"> * 754       | 0754</span>
<span style="color: #008000"> * 1015      | 1015</span>
<span style="color: #008000"> *</span>
<span style="color: #008000"> * @param numberToConver numero entero a convertir.</span>
<span style="color: #008000"> * @param stringNumber puntero al vector donde se</span>
<span style="color: #008000"> * almacenara el string convertido.</span>
<span style="color: #008000"> * @return 0 si no hubo error, 1 si hubo error.</span>
<span style="color: #008000"> */</span>
<span style="color: #0000ff">static</span> <span style="color: #2b91af">bool_t</span> AnalogValueToString (<span style="color: #2b91af">uint16_t</span> numberToConvert, <span style="color: #2b91af">char</span> * strNumber)
{
    <span style="color: #2b91af">bool_t</span> error = FALSE;
    <span style="color: #2b91af">uint8_t</span> thousands = 0;
    <span style="color: #2b91af">uint8_t</span> hundreds = 0;
    <span style="color: #2b91af">uint8_t</span> tens = 0;
    <span style="color: #2b91af">uint8_t</span> units = 0;

    <span style="color: #0000ff">if</span> (numberToConvert &lt;= MAX_ANALOG_VALUE)
    {
        thousands = numberToConvert / 1000;
        hundreds = numberToConvert / 100;
        <span style="color: #0000ff">if</span> (hundreds &gt;= 10)
        {
            hundreds = 0;
        }
        tens = numberToConvert;
        tens -= ((thousands * 1000) + (hundreds * 100));
        tens /= 10;
        units = numberToConvert;
        units -= ((thousands * 1000) + (hundreds * 100) + (tens * 10));

        strNumber[0] = thousands + <span style="color: #a31515">&#39;0&#39;</span>;
        strNumber[1] = hundreds + <span style="color: #a31515">&#39;0&#39;</span>;
        strNumber[2] = tens + <span style="color: #a31515">&#39;0&#39;</span>;
        strNumber[3] = units + <span style="color: #a31515">&#39;0&#39;</span>;
        strNumber[4] = <span style="color: #a31515">&#39;\0&#39;</span>;
    }
    <span style="color: #0000ff">else</span>
    {
        error = TRUE;
    }
    <span style="color: #0000ff">return</span> !error;
}

<span style="color: #008000">/**</span>
<span style="color: #008000"> * Chequea que el comando a enviar hacia la aplicacion de hardware virtual</span>
<span style="color: #008000"> * sea un comando valido. Por ejemplo, no se puede ejecutar el comando de</span>
<span style="color: #008000"> * escribrir un GPIO en el periferico LCD o no se puede realizar el comando</span>
<span style="color: #008000"> * de leer un analogico de un pin digital.</span>
<span style="color: #008000"> * Para cada comando, chequea que el periferico sea correcto.</span>
<span style="color: #008000"> * @param command comando a enviar a la aplicacion.</span>
<span style="color: #008000"> * @param perMap periferico virtual sobre el cual se ejecutara el comando.</span>
<span style="color: #008000"> * @return 1 si es una combinacion comando/periferico valida, 0 si no lo es.</span>
<span style="color: #008000"> */</span>
<span style="color: #0000ff">static</span> <span style="color: #2b91af">bool_t</span> CheckIfValidCommand (ViHardCommand_t command,
        ViHardPeriph_t perMap)
{
    <span style="color: #2b91af">bool_t</span> isValidCommand = FALSE;
    <span style="color: #0000ff">if</span> (command == VH_GPIO_READ)
    {
        <span style="color: #0000ff">if</span> (perMap == VH_TEC1 || perMap == VH_TEC2 ||
            perMap == VH_TEC3 || perMap == VH_TEC4)
        {
            isValidCommand = TRUE;
        }
        <span style="color: #0000ff">if</span> (perMap == VH_LEDR || perMap == VH_LEDG || perMap == VH_LEDB ||
            perMap == VH_LED1 || perMap == VH_LED2 || perMap == VH_LED3 ||
            perMap == VH_LED4)
        {
            isValidCommand = TRUE;
        }
    }
    <span style="color: #0000ff">else</span> <span style="color: #0000ff">if</span> (command == VH_GPIO_WRITE)
    {
        <span style="color: #0000ff">if</span> (perMap == VH_LEDR || perMap == VH_LEDG || perMap == VH_LEDB ||
            perMap == VH_LED1 || perMap == VH_LED2 || perMap == VH_LED3 ||
            perMap == VH_LED4)
        {
            isValidCommand = TRUE;
        }
    }
    <span style="color: #0000ff">else</span> <span style="color: #0000ff">if</span> (command == VH_ADC_READ)
    {
        <span style="color: #0000ff">if</span> (perMap == VH_ADC_CH1)
        {
            isValidCommand = TRUE;
        }
    }
    <span style="color: #0000ff">else</span> <span style="color: #0000ff">if</span> (command == VH_DAC_WRITE)
    {
        <span style="color: #0000ff">if</span> (perMap == VH_DAC_CH1)
        {
            isValidCommand = TRUE;
        }
    }
    <span style="color: #0000ff">else</span> <span style="color: #0000ff">if</span> (command == VH_LCD_WRITE_BYTE || command == VH_LCD_WRITE_STRING)
    {
        <span style="color: #0000ff">if</span> (perMap == VH_LCD1)
        {
            isValidCommand = TRUE;
        }
    }
    <span style="color: #0000ff">else</span> <span style="color: #0000ff">if</span> (command == VH_7SEG_WRITE &amp;&amp; perMap == VH_7SEG)
    {
        isValidCommand = TRUE;
    }

    <span style="color: #0000ff">if</span> (isValidCommand)
    {
        DelayMs(MS_BETWEEN_COMMANDS);
    }

    <span style="color: #0000ff">return</span> isValidCommand;
}

<span style="color: #008000">/**</span>
<span style="color: #008000"> * Realiza la lectura de datos provenientes del puerto serie.</span>
<span style="color: #008000"> * Dentro de la funcion se chequea que los datos leidos sean una</span>
<span style="color: #008000"> * trama valida, es decir, se espera que la trama este comprendida</span>
<span style="color: #008000"> * dentro de los caracteres de control COMMAND_INIT y COMMAND_END.</span>
<span style="color: #008000"> * La forma de salir de la funcion es si se cumplio un tiempo determinado</span>
<span style="color: #008000"> * o si llego el dato COMMAND_END</span>
<span style="color: #008000"> * @param buffer el buffer donde se almacenaran los datos leidos</span>
<span style="color: #008000"> * @param timeToWait el tiempo que se espero para que lleguen datos</span>
<span style="color: #008000"> * @param bytesRead la cantidad de bytes leidos</span>
<span style="color: #008000"> */</span>
<span style="color: #0000ff">static</span> <span style="color: #2b91af">uint8_t</span> WaitForSerialData (<span style="color: #2b91af">char</span> * buffer, <span style="color: #2b91af">uint16_t</span> * timeWaited)
{
    <span style="color: #2b91af">bool_t</span> flagCommandInit = FALSE;
    <span style="color: #2b91af">uint8_t</span> bytesRead = 0;
    <span style="color: #2b91af">uint8_t</span> dataSerial = 0;

    <span style="color: #008000">// Espera a recibir data por un tiempo determinado</span>
    <span style="color: #0000ff">while</span> (++(*timeWaited) &lt; MAX_TIME_TO_WAIT_FOR_SERIAL_DATA)
    {
        <span style="color: #0000ff">if</span> ((dataSerial = UartReadByte()) != 0)
        {
            <span style="color: #0000ff">if</span> (dataSerial == COMMAND_INIT)
            {
                flagCommandInit = TRUE;
            }
            <span style="color: #0000ff">if</span> (flagCommandInit)
            {
                buffer[bytesRead] = dataSerial;
                <span style="color: #0000ff">if</span> (buffer[bytesRead] == COMMAND_END)
                {
                    <span style="color: #0000ff">break</span>;
                }
                bytesRead++;
            }
        }
    }
    <span style="color: #0000ff">return</span> bytesRead;
}

<span style="color: #008000">/**</span>
<span style="color: #008000"> * Limpia un buffer de cualquier tipo</span>
<span style="color: #008000"> * @param buffer el buffer a limpiar</span>
<span style="color: #008000"> * @param el tamaño a limpiar</span>
<span style="color: #008000"> */</span>
<span style="color: #0000ff">static</span> <span style="color: #2b91af">void</span> CleanSerialBuffer (<span style="color: #2b91af">char</span> * buffer, <span style="color: #2b91af">uint32_t</span> size){
    <span style="color: #2b91af">uint32_t</span> i;

    <span style="color: #0000ff">for</span> (i = 0; i &lt; size; i++){
        buffer[i] = 0;
    }
}

<span style="color: #008000">/*==================[external functions definition]==========================*/</span>

<span style="color: #008000">/**</span>
<span style="color: #008000"> * Configura el puerto serie por el que se va a comunicar el sistema embebido</span>
<span style="color: #008000"> * con la plataforma de hardware virtual.</span>
<span style="color: #008000"> * Se elige que solo se reciba la velocidad de la uart y no a que uart se va</span>
<span style="color: #008000"> * a conectar ya que el framework de Arduino unicamente recibe como parametro</span>
<span style="color: #008000"> * la velocidad de conexion.</span>
<span style="color: #008000"> * @param baudRate velocidad de transmision.</span>
<span style="color: #008000"> * @return 1 siempre.</span>
<span style="color: #008000"> */</span>
<span style="color: #2b91af">bool_t</span> Vh_BoardConfig (<span style="color: #2b91af">uint32_t</span> baudRate)
{
    <span style="color: #008000">// dependiendo de la velocidad se establece el tiempo de espera entre lecturas</span>
    <span style="color: #008000">// si el baudrate es un valor desconocido le pone el equivalente a 115200</span>
    <span style="color: #0000ff">switch</span> (baudRate){
        <span style="color: #0000ff">case</span> 115200: UsBetweenReads = 9;   <span style="color: #0000ff">break</span>;
        <span style="color: #0000ff">case</span> 57600:  UsBetweenReads = 17;  <span style="color: #0000ff">break</span>;
        <span style="color: #0000ff">case</span> 38400:  UsBetweenReads = 26;  <span style="color: #0000ff">break</span>;
        <span style="color: #0000ff">case</span> 19200:  UsBetweenReads = 52;  <span style="color: #0000ff">break</span>;
        <span style="color: #0000ff">case</span> 9600:   UsBetweenReads = 104; <span style="color: #0000ff">break</span>;
        default:     UsBetweenReads = 9;
    }
    UART_CONFIG(baudRate);

    <span style="color: #0000ff">return</span> TRUE;
}

<span style="color: #008000">/**</span>
<span style="color: #008000"> * Escribe un estado logico en un pin virtual.</span>
<span style="color: #008000"> * @param virtualGpioPin pin virtual a escribir.</span>
<span style="color: #008000"> * @param pinState estado logico a enviar.</span>
<span style="color: #008000"> */</span>
<span style="color: #2b91af">void</span> Vh_GpioWrite (ViHardPeriph_t gpioPin, <span style="color: #2b91af">bool_t</span> pinState)
{
    <span style="color: #2b91af">char</span> stringCommand[10];

    <span style="color: #0000ff">if</span> (CheckIfValidCommand(VH_GPIO_WRITE, gpioPin))
    {
        stringCommand[0] = COMMAND_INIT;
        stringCommand[1] = VH_GPIO_WRITE;
        stringCommand[2] = COMMAND_SEPARATOR;
        stringCommand[3] = gpioPin;
        stringCommand[4] = COMMAND_SEPARATOR;
        stringCommand[5] = pinState == TRUE ? VH_GPIO_HIGH : VH_GPIO_LOW;
        stringCommand[6] = COMMAND_END;
        stringCommand[7] = <span style="color: #a31515">&#39;\n&#39;</span>;
        stringCommand[8] = <span style="color: #a31515">&#39;\0&#39;</span>;

        UartWriteString(stringCommand);
    }
}

<span style="color: #008000">/**</span>
<span style="color: #008000"> * Lee el estado logico de un pin virtual.</span>
<span style="color: #008000"> * @param virtualGpioPin pin virtual a leer.</span>
<span style="color: #008000"> * @return estado logico leido.</span>
<span style="color: #008000"> */</span>
<span style="color: #2b91af">bool_t</span> Vh_GpioRead (ViHardPeriph_t gpioPin)
{
    <span style="color: #2b91af">char</span> stringCommand[10];
    <span style="color: #2b91af">bool_t</span> pinState = TRUE;
    <span style="color: #2b91af">uint16_t</span> timeWaited = 0;
    <span style="color: #2b91af">uint8_t</span> bytesRead = 0;

    <span style="color: #0000ff">if</span> (CheckIfValidCommand(VH_GPIO_READ, gpioPin))
    {
        stringCommand[0] = COMMAND_INIT;
        stringCommand[1] = VH_GPIO_READ;
        stringCommand[2] = COMMAND_SEPARATOR;
        stringCommand[3] = gpioPin;
        stringCommand[4] = COMMAND_SEPARATOR;
        stringCommand[5] = VH_COMM_REQUEST;
        stringCommand[6] = COMMAND_END;
        stringCommand[7] = <span style="color: #a31515">&#39;\n&#39;</span>;
        stringCommand[8] = <span style="color: #a31515">&#39;\0&#39;</span>;

        UartWriteString(stringCommand);

        CleanSerialBuffer(stringCommand, 10);

        bytesRead = WaitForSerialData(stringCommand, &amp;timeWaited);

        <span style="color: #008000">// chequea si salio por timeout y</span>
        <span style="color: #008000">// chequea que todos lo que haya llegado sea una respuesta correcta</span>
        <span style="color: #0000ff">if</span> (bytesRead == 8 &amp;&amp;
            timeWaited &lt; 1000 &amp;&amp;
            stringCommand[0] == COMMAND_INIT &amp;&amp;
            stringCommand[1] == VH_GPIO_READ &amp;&amp;
            stringCommand[2] == COMMAND_SEPARATOR &amp;&amp;
            stringCommand[4] == COMMAND_SEPARATOR &amp;&amp;
            stringCommand[5] == VH_COMM_RESPONSE &amp;&amp;
            stringCommand[6] == COMMAND_SEPARATOR &amp;&amp;
            (stringCommand[7] == VH_GPIO_LOW ||
            stringCommand[7] == VH_GPIO_HIGH))
        {
            pinState = stringCommand[7] - <span style="color: #a31515">&#39;0&#39;</span>;
        }
    }

    <span style="color: #0000ff">return</span> pinState;
}

<span style="color: #008000">/**</span>
<span style="color: #008000"> * Invierte el estado logico de un pin.</span>
<span style="color: #008000"> * Notar que para que esta accion se realice, el pin a invertir su estado</span>
<span style="color: #008000"> * debe ser un pin de salida.</span>
<span style="color: #008000"> * @param virtualGpioPin pin a invertir el estado logico.</span>
<span style="color: #008000"> */</span>
<span style="color: #2b91af">void</span> Vh_GpioToggle (ViHardPeriph_t gpioPin)
{
    Vh_GpioWrite(gpioPin, !Vh_GpioRead(gpioPin));
}

<span style="color: #008000">/**</span>
<span style="color: #008000"> * Realiza una lectura sobre un pin analogico.</span>
<span style="color: #008000"> * La conversion ADC tiene una resolucion de 10 bits, por lo que, sus</span>
<span style="color: #008000"> * valores estan comprendidos entre 0 y 1023.</span>
<span style="color: #008000"> * @param virtualAdcPin pin analogico virtual a leer.</span>
<span style="color: #008000"> * @return valor analogico leido.</span>
<span style="color: #008000"> */</span>
<span style="color: #2b91af">uint16_t</span> Vh_AdcRead (ViHardPeriph_t adcChannel)
{
    <span style="color: #2b91af">char</span> stringCommand[15];
    <span style="color: #0000ff">static</span> <span style="color: #2b91af">uint16_t</span> adcValue = 0;
    <span style="color: #2b91af">uint16_t</span> timeWaited = 0;
    <span style="color: #2b91af">uint8_t</span> bytesRead = 0;

    <span style="color: #0000ff">if</span> (CheckIfValidCommand(VH_ADC_READ, adcChannel))
    {
        stringCommand[0] = COMMAND_INIT;
        stringCommand[1] = VH_ADC_READ;
        stringCommand[2] = COMMAND_SEPARATOR;
        stringCommand[3] = adcChannel;
        stringCommand[4] = COMMAND_SEPARATOR;
        stringCommand[5] = VH_COMM_REQUEST;
        stringCommand[6] = COMMAND_END;
        stringCommand[7] = <span style="color: #a31515">&#39;\n&#39;</span>;
        stringCommand[8] = <span style="color: #a31515">&#39;\0&#39;</span>;

        UartWriteString(stringCommand);

        CleanSerialBuffer(stringCommand, 15);

        bytesRead = WaitForSerialData(stringCommand, &amp;timeWaited);

        <span style="color: #008000">// chequea si salio por timeout y</span>
        <span style="color: #008000">// chequea que todos lo que haya llegado sea una respuesta correcta</span>
        <span style="color: #0000ff">if</span> (bytesRead == 11 &amp;&amp;
            timeWaited &lt; 1000 &amp;&amp;
            stringCommand[0] == COMMAND_INIT &amp;&amp;
            stringCommand[1] == VH_ADC_READ&amp;&amp;
            stringCommand[2] == COMMAND_SEPARATOR &amp;&amp;
            stringCommand[3] == adcChannel &amp;&amp;
            stringCommand[4] == COMMAND_SEPARATOR &amp;&amp;
            stringCommand[5] == VH_COMM_RESPONSE &amp;&amp;
            stringCommand[6] == COMMAND_SEPARATOR &amp;&amp;
            stringCommand[11] == COMMAND_END)
        {
            adcValue = 0;
            <span style="color: #008000">// unidades de mil</span>
            adcValue += (stringCommand[7] - <span style="color: #a31515">&#39;0&#39;</span>) * 1000;
            <span style="color: #008000">// centenas</span>
            adcValue += (stringCommand[8] - <span style="color: #a31515">&#39;0&#39;</span>) * 100;
            <span style="color: #008000">// decenas</span>
            adcValue += (stringCommand[9] - <span style="color: #a31515">&#39;0&#39;</span>) * 10;
            <span style="color: #008000">// unidades</span>
            adcValue += (stringCommand[10] - <span style="color: #a31515">&#39;0&#39;</span>);

            <span style="color: #0000ff">if</span> (adcValue &gt; MAX_ANALOG_VALUE)
            {
                adcValue = MAX_ANALOG_VALUE;
            }
        }
    }

    <span style="color: #0000ff">return</span> adcValue;
}

<span style="color: #008000">/**</span>
<span style="color: #008000"> * Escribe un valor analogico sobre una salida analogica.</span>
<span style="color: #008000"> * El valor a escribir es de 10 bits, por lo que, sus</span>
<span style="color: #008000"> * valores estan comprendidos entre 0 y 1023.</span>
<span style="color: #008000"> * @param dacChannel pin analogico a escribir.</span>
<span style="color: #008000"> * @param dacValue valor de 10 bits a escribir.</span>
<span style="color: #008000"> */</span>
<span style="color: #2b91af">void</span> Vh_DacWrite (ViHardPeriph_t dacChannel, <span style="color: #2b91af">uint16_t</span> dacValue)
{
    <span style="color: #2b91af">char</span> stringCommand[15];
    <span style="color: #2b91af">char</span> analogString[5];

    <span style="color: #0000ff">if</span> (CheckIfValidCommand(VH_DAC_WRITE, dacChannel))
    {
        <span style="color: #0000ff">if</span> (dacValue &gt; MAX_ANALOG_VALUE)
        {
            dacValue = MAX_ANALOG_VALUE;
        }

        <span style="color: #0000ff">if</span> (AnalogValueToString(dacValue, analogString))
        {
            stringCommand[0]  = COMMAND_INIT;
            stringCommand[1]  = VH_DAC_WRITE;
            stringCommand[2]  = COMMAND_SEPARATOR;
            stringCommand[3]  = dacChannel;
            stringCommand[4]  = COMMAND_SEPARATOR;
            stringCommand[5]  = analogString[0];
            stringCommand[6]  = analogString[1];
            stringCommand[7]  = analogString[2];
            stringCommand[8]  = analogString[3];
            stringCommand[9]  = COMMAND_END;
            stringCommand[10] = <span style="color: #a31515">&#39;\n&#39;</span>;
            stringCommand[11] = <span style="color: #a31515">&#39;\0&#39;</span>;

            UartWriteString(stringCommand);
        }
    }
}

<span style="color: #008000">/**</span>
<span style="color: #008000"> * Escribe un caracter ASCII sobre el periferico display 7 segmentos.</span>
<span style="color: #008000"> * A diferencia de un display 7 segmentos real, este display, por el tipo</span>
<span style="color: #008000"> * de letra elegido, puede escribir cualquier caracter ASCII sobre el display</span>
<span style="color: #008000"> * a diferencia de uno tradicional que puede escribir del 0-9 y A-F.</span>
<span style="color: #008000"> * @param display periferico del display 7 segmentos.</span>
<span style="color: #008000"> * @param valueToShow caracter ASCII a mostrar sobre el display.</span>
<span style="color: #008000"> */</span>
<span style="color: #2b91af">void</span> Vh_7SegmentsWrite (ViHardPeriph_t display7Segs, <span style="color: #2b91af">uint8_t</span> asciiToShow)
{
    <span style="color: #2b91af">char</span> stringCommand[10];

    <span style="color: #0000ff">if</span> (CheckIfValidCommand(VH_7SEG_WRITE, display7Segs))
    {
        stringCommand[0] = COMMAND_INIT;
        stringCommand[1] = VH_7SEG_WRITE;
        stringCommand[2] = COMMAND_SEPARATOR;
        stringCommand[3] = display7Segs;
        stringCommand[4] = COMMAND_SEPARATOR;
        stringCommand[5] = asciiToShow;
        stringCommand[6] = COMMAND_END;
        stringCommand[7] = <span style="color: #a31515">&#39;\n&#39;</span>;
        stringCommand[8] = <span style="color: #a31515">&#39;\0&#39;</span>;

        UartWriteString(stringCommand);
    }
}

<span style="color: #008000">/**</span>
<span style="color: #008000"> * Escribe un texto sobre el periferico display LCD.</span>
<span style="color: #008000"> * Como en el caso de un display LCD real, se puede seleccionar la linea</span>
<span style="color: #008000"> * sobre la cual escribir el texto.</span>
<span style="color: #008000"> * @param display periferico del display lcd sobre el cual escribir.</span>
<span style="color: #008000"> * @param lcdLine la linea sobre la cual escribir el mensaje, los posibles</span>
<span style="color: #008000"> * valores de la lineas son:</span>
<span style="color: #008000"> * --- LCD_LINE_ALL: escribe un mensaje multilinea.</span>
<span style="color: #008000"> * --- LCD_LINE_FIRST: escribe en la primer linea.</span>
<span style="color: #008000"> * --- LCD_LINE_SECOND: escribe en la segunda linea.</span>
<span style="color: #008000"> * --- LCD_LINE_THIRD: escribe en la tercer linea.</span>
<span style="color: #008000"> * @param stringToWrite cadena a escribir</span>
<span style="color: #008000"> */</span>
<span style="color: #2b91af">void</span> Vh_LcdWriteString (ViHardPeriph_t displayLcd, LcdLine_t line, <span style="color: #2b91af">char</span> * str)
{
    <span style="color: #2b91af">uint8_t</span> i = 0;
    <span style="color: #2b91af">uint8_t</span> lenght = 0;
    <span style="color: #2b91af">char</span> stringCommand[70];

    <span style="color: #0000ff">if</span> (CheckIfValidCommand(VH_LCD_WRITE_STRING, displayLcd))
    {
        <span style="color: #0000ff">for</span> (lenght = 0; str[lenght] != <span style="color: #a31515">&#39;\0&#39;</span>; lenght++);

        stringCommand[0] = COMMAND_INIT;
        stringCommand[1] = VH_LCD_WRITE_STRING;
        stringCommand[2] = COMMAND_SEPARATOR;
        stringCommand[3] = displayLcd;
        stringCommand[4] = COMMAND_SEPARATOR;
        stringCommand[5] = line;
        stringCommand[6] = COMMAND_SEPARATOR;

        <span style="color: #0000ff">for</span> (i = 0; i &lt; lenght; i++)
        {
            stringCommand[i + 7] = str[i];
        }

        stringCommand[7 + lenght] = COMMAND_END;
        stringCommand[8 + lenght] = <span style="color: #a31515">&#39;\n&#39;</span>;
        stringCommand[9 + lenght] = <span style="color: #a31515">&#39;\0&#39;</span>;

        UartWriteString(stringCommand);
    }
}

<span style="color: #008000">/*==================[end of file]============================================*/</span>
</pre></div>
    