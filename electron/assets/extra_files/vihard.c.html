<!-- HTML generated using hilite.me -->
<div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><table><tr><td><pre style="margin: 0; line-height: 125%">
  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
224
225
226
227
228
229
230
231
232
233
234
235
236
237
238
239
240
241
242
243
244
245
246
247
248
249
250
251
252
253
254
255
256
257
258
259
260
261
262
263
264
265
266
267
268
269
270
271
272
273
274
275
276
277
278
279
280
281
282
283
284
285
286
287
288
289
290
291
292
293
294
295
296
297
298
299
300
301
302
303
304
305
306
307
308
309
310
311
312
313
314
315
316
317
318
319
320
321
322
323
324
325
326
327
328
329
330
331
332
333
334
335
336
337
338
339
340
341
342
343
344
345
346
347
348
349
350
351
352
353
354
355
356
357
358
359
360
361
362
363
364
365
366
367
368
369
370
371
372
373
374
375
376
377
378
379
380
381
382
383
384
385
386
387
388
389
390
391
392
393
394
395
396
397
398
399
400
401
402
403
404
405
406
407
408
409
410
411
412
413
414
415
416
417
418
419
420
421
422
423
424
425
426
427
428
429
430
431
432
433
434
435
436
437
438
439
440
441
442
443
444
445
446
447
448
449
450
451
452
453
454
455
456
457
458
459
460
461
462
463
464
465
466
467
468
469
470
471
472
473
474
475
476
477
478
479
480
481
482
483
484
485
486
487
488
489
490
491
492
493
494
495
496
497
498
499
500
501
502
503
504
505
506
507
508
509
510
511
512
513
514
515
516
517
518
519
520
521
522
523
524
525
526
527
528
529
530
531
532
533
534
535
536
537
538
539
540
541
542
543
544
545
546
547
548
549
550
551
552
553
554
555
556
557
558
559
560
561
562
563
564
565
566
567
568
569
570
571
572
573
574
575
576
577
578
579
580
581
582
583
584
585
586
587
588
589
590
591
592
593
594
595
596
597
598
599
600
601
602
603
604
605
606
607
608
609
610
611
612
613
614
615
616
617
618
619
620
621
622
623
624
625
626
627
628
629
630
631
632
633
634
635
636
637
638
639
640
641
642
643
644
645
646
647
648
649
650
651
652
    </pre></td><td><pre style="margin: 0; line-height: 125%">
<span style="color: #008000">/* Copyright 2018, Agustin Bassi.</span>
<span style="color: #008000"> * All rights reserved.</span>
<span style="color: #008000"> *</span>
<span style="color: #008000"> * This file is part ViHard library, a library of virtual hardware</span>
<span style="color: #008000"> * for Embedded Systems.</span>
<span style="color: #008000"> *</span>
<span style="color: #008000"> * Redistribution and use in source and binary forms, with or without</span>
<span style="color: #008000"> * modification, are permitted provided that the following conditions are met:</span>
<span style="color: #008000"> *</span>
<span style="color: #008000"> * 1. Redistributions of source code must retain the above copyright notice,</span>
<span style="color: #008000"> *    this list of conditions and the following disclaimer.</span>
<span style="color: #008000"> *</span>
<span style="color: #008000"> * 2. Redistributions in binary form must reproduce the above copyright notice,</span>
<span style="color: #008000"> *    this list of conditions and the following disclaimer in the documentation</span>
<span style="color: #008000"> *    and/or other materials provided with the distribution.</span>
<span style="color: #008000"> *</span>
<span style="color: #008000"> * 3. Neither the name of the copyright holder nor the names of its</span>
<span style="color: #008000"> *    contributors may be used to endorse or promote products derived from this</span>
<span style="color: #008000"> *    software without specific prior written permission.</span>
<span style="color: #008000"> *</span>
<span style="color: #008000"> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;</span>
<span style="color: #008000"> * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</span>
<span style="color: #008000"> * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</span>
<span style="color: #008000"> * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE</span>
<span style="color: #008000"> * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR</span>
<span style="color: #008000"> * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF</span>
<span style="color: #008000"> * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS</span>
<span style="color: #008000"> * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN</span>
<span style="color: #008000"> * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)</span>
<span style="color: #008000"> * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE</span>
<span style="color: #008000"> * POSSIBILITY OF SUCH DAMAGE.</span>
<span style="color: #008000"> *</span>
<span style="color: #008000"> */</span>

<span style="color: #008000">/* Date: 2018-10-02 */</span>

<span style="color: #008000">/*==================[inclusions]=============================================*/</span>

<span style="color: #0000ff">#include &lt;math.h&gt;</span>

<span style="color: #0000ff">#include &quot;vihard.h&quot;</span>

<span style="color: #008000">/*==================[macros and definitions]=================================*/</span>

<span style="color: #0000ff">#define COMMAND_INIT            &#39;{&#39;</span>
<span style="color: #0000ff">#define COMMAND_END             &#39;}&#39;</span>
<span style="color: #0000ff">#define COMMAND_SEPARATOR       &#39;;&#39;</span>

<span style="color: #0000ff">#define MAX_ANALOG_VALUE        1023</span>

<span style="color: #0000ff">#define MS_BETWEEN_COMMANDS     7</span>

<span style="color: #0000ff">#define VH_GPIO_LOW		        &#39;0&#39;</span>
<span style="color: #0000ff">#define VH_GPIO_HIGH            &#39;1&#39;</span>
<span style="color: #0000ff">#define VH_GPIO_INVALID	        -1</span>

<span style="color: #008000">/**</span>
<span style="color: #008000"> * Posibles tipos de comandos que se pueden realizar. Este enum es utilizado</span>
<span style="color: #008000"> * unicamente en los comandos de lectura de perifericos virtuales. Cuando el</span>
<span style="color: #008000"> * sistema embebido quiere leer le enviar un REQUEST y la aplicacion responde</span>
<span style="color: #008000"> * con un RESPONSE.</span>
<span style="color: #008000"> */</span>
<span style="color: #0000ff">typedef</span> <span style="color: #0000ff">enum</span> _ViHardCommandType {
    VH_COMM_REQUEST  = <span style="color: #a31515">&#39;0&#39;</span>, <span style="color: #008000">//!&lt; COMM_SERIAL_REQUEST</span>
    VH_COMM_RESPONSE = <span style="color: #a31515">&#39;1&#39;</span>  <span style="color: #008000">//!&lt; COMM_SERIAL_RESPONSE</span>
} ViHardCommandType_t;

<span style="color: #008000">/**</span>
<span style="color: #008000"> * Posibles llamadas a los perifericos virtuales que se pueden realizar.</span>
<span style="color: #008000"> */</span>
<span style="color: #0000ff">typedef</span> <span style="color: #0000ff">enum</span> _ViHardCommand {
    <span style="color: #008000">//Comandos asociados a GPIO</span>
    VH_GPIO_READ        = <span style="color: #a31515">&#39;a&#39;</span>,
    VH_GPIO_WRITE       = <span style="color: #a31515">&#39;b&#39;</span>,
    <span style="color: #008000">//Comandos asociados al ADC/DAC</span>
    VH_ADC_READ         = <span style="color: #a31515">&#39;c&#39;</span>,
    VH_DAC_WRITE        = <span style="color: #a31515">&#39;d&#39;</span>,
    <span style="color: #008000">// Comandos asociados al display LCD</span>
    VH_LCD_WRITE_BYTE   = <span style="color: #a31515">&#39;e&#39;</span>,
    VH_LCD_WRITE_STRING = <span style="color: #a31515">&#39;f&#39;</span>,
    <span style="color: #008000">// Comandos asociados al display LCD</span>
    VH_7SEG_WRITE       = <span style="color: #a31515">&#39;g&#39;</span>,
} ViHardCommand_t;

<span style="color: #008000">/*==================[internal data declaration]==============================*/</span>

<span style="color: #008000">/*==================[internal functions declaration]=========================*/</span>

<span style="color: #0000ff">static</span> <span style="color: #2b91af">void</span>     UartWriteByte       (<span style="color: #2b91af">uint8_t</span> byteToWrite);
<span style="color: #0000ff">static</span> <span style="color: #2b91af">uint8_t</span>  UartReadByte        (<span style="color: #2b91af">void</span>);
<span style="color: #0000ff">static</span> <span style="color: #2b91af">void</span>     UartWriteString     (<span style="color: #2b91af">char</span> * string);
<span style="color: #0000ff">static</span> <span style="color: #2b91af">void</span>     DelayMs             (<span style="color: #2b91af">uint32_t</span> delayMs);
<span style="color: #0000ff">static</span> <span style="color: #2b91af">void</span>     DelayUs             (<span style="color: #2b91af">uint32_t</span> delayMs);
<span style="color: #0000ff">static</span> <span style="color: #2b91af">bool_t</span>   CheckIfValidCommand (ViHardCommand_t comm, ViHardPeriph_t perMap);
<span style="color: #0000ff">static</span> <span style="color: #2b91af">bool_t</span>   AnalogValueToString (<span style="color: #2b91af">uint16_t</span> numToConvert, <span style="color: #2b91af">char</span> * strNumber);

<span style="color: #008000">/*==================[internal data definition]===============================*/</span>

<span style="color: #008000">// Cuando se quieren leer datos del puerto serie se debe esperar</span>
<span style="color: #008000">// un tiempo proporcional al baudrate seleccionado. Esta variable</span>
<span style="color: #008000">// estatica se utiliza para este proposito.</span>
<span style="color: #0000ff">static</span> <span style="color: #2b91af">uint32_t</span> UsBetweenReads = 1000000 / VIHARD_BAUDRATE;

<span style="color: #008000">/*==================[external data definition]===============================*/</span>

<span style="color: #008000">/*==================[internal functions definition]==========================*/</span>

<span style="color: #008000">/**</span>
<span style="color: #008000"> * Funcion propia para llamar a la funcion de sacar un</span>
<span style="color: #008000"> * byte por la uart seleccionada cuando se configuro al modulo.</span>
<span style="color: #008000"> * @param byteToWrite byte a escribir en el puerto serie.</span>
<span style="color: #008000"> */</span>
<span style="color: #0000ff">static</span> <span style="color: #2b91af">void</span> UartWriteByte (<span style="color: #2b91af">uint8_t</span> byteToWrite)
{
    UART_WRITE_BYTE(byteToWrite);
}

<span style="color: #008000">/**</span>
<span style="color: #008000"> * Funcion propia para leer un byte del puerto serie.</span>
<span style="color: #008000"> * Como en funciones anteriores, las funciones de este modulo invocan</span>
<span style="color: #008000"> * estas funciones en vez de la de una plataforma en particular. Esto</span>
<span style="color: #008000"> * se realiza de esta manera para darle independencia al codigo para que</span>
<span style="color: #008000"> * pueda ser multiplataforma.</span>
<span style="color: #008000"> * @return el byte leido por la uart.</span>
<span style="color: #008000"> */</span>
<span style="color: #0000ff">static</span> <span style="color: #2b91af">uint8_t</span> UartReadByte (<span style="color: #2b91af">void</span>)
{
    <span style="color: #0000ff">static</span> <span style="color: #2b91af">uint8_t</span> byteReaded;

    <span style="color: #0000ff">if</span> (!UART_READ_BYTE(byteReaded))
    {
        byteReaded = 0;
    }
    DelayUs(UsBetweenReads);

    <span style="color: #0000ff">return</span> byteReaded;
}

<span style="color: #008000">/**</span>
<span style="color: #008000"> * Escribe un string por la uart. En algunas platadormas, esta funcion</span>
<span style="color: #008000"> * es soportada de manera nativa por el framework que brinda acceso al</span>
<span style="color: #008000"> * hardware, en otras plataformas, para mandar un string por la uart es</span>
<span style="color: #008000"> * necesario llamar a la funcion de escribir un byte hasta completar</span>
<span style="color: #008000"> * todos los bytes del string.</span>
<span style="color: #008000"> * @param string puntero al string a enviar por la uart.</span>
<span style="color: #008000"> */</span>
<span style="color: #0000ff">static</span> <span style="color: #2b91af">void</span> UartWriteString (<span style="color: #2b91af">char</span> * string)
{
    <span style="color: #0000ff">while</span> (*string != 0)
    {
        UartWriteByte((<span style="color: #2b91af">uint8_t</span>) * string);
        string++;
    }
}

<span style="color: #008000">/**</span>
<span style="color: #008000"> * Funcion propia para llamar al delay de la plataforma.</span>
<span style="color: #008000"> * @param delayMs</span>
<span style="color: #008000"> */</span>
<span style="color: #0000ff">static</span> <span style="color: #2b91af">void</span> DelayUs (<span style="color: #2b91af">uint32_t</span> microSecs)
{
    <span style="color: #0000ff">volatile</span> <span style="color: #2b91af">uint64_t</span> i;
    <span style="color: #0000ff">volatile</span> <span style="color: #2b91af">uint64_t</span> calculatedDelay;

    calculatedDelay = (CLOCK_SPEED_MHZ * microSecs) / 10;

    <span style="color: #0000ff">for</span>(i = calculatedDelay; i &gt; 0; i--);
}

<span style="color: #008000">/**</span>
<span style="color: #008000"> * Funcion propia para llamar al delay de la plataforma.</span>
<span style="color: #008000"> * @param delayMs</span>
<span style="color: #008000"> */</span>
<span style="color: #0000ff">static</span> <span style="color: #2b91af">void</span> DelayMs (<span style="color: #2b91af">uint32_t</span> delayMs)
{
    DelayUs(delayMs * 1000);
}

<span style="color: #008000">/**</span>
<span style="color: #008000"> * Convierte un numero entero analogico de 10 bits (entre 0 y 1023) en un</span>
<span style="color: #008000"> * string de 4 elementos. El numero siempre sale en formato 4 digitos.</span>
<span style="color: #008000"> *</span>
<span style="color: #008000"> * Ejemplos:</span>
<span style="color: #008000"> *</span>
<span style="color: #008000"> * valor int | valor string</span>
<span style="color: #008000"> * 9         | 0009</span>
<span style="color: #008000"> * 75        | 0075</span>
<span style="color: #008000"> * 754       | 0754</span>
<span style="color: #008000"> * 1015      | 1015</span>
<span style="color: #008000"> *</span>
<span style="color: #008000"> * @param numberToConver numero entero a convertir.</span>
<span style="color: #008000"> * @param stringNumber puntero al vector donde se</span>
<span style="color: #008000"> * almacenara el string convertido.</span>
<span style="color: #008000"> * @return 0 si no hubo error, 1 si hubo error.</span>
<span style="color: #008000"> */</span>
<span style="color: #0000ff">static</span> <span style="color: #2b91af">bool_t</span> AnalogValueToString (<span style="color: #2b91af">uint16_t</span> numberToConvert, <span style="color: #2b91af">char</span> * strNumber)
{
    <span style="color: #2b91af">bool_t</span> error = FALSE;
    <span style="color: #2b91af">uint8_t</span> thousands = 0;
    <span style="color: #2b91af">uint8_t</span> hundreds = 0;
    <span style="color: #2b91af">uint8_t</span> tens = 0;
    <span style="color: #2b91af">uint8_t</span> units = 0;

    <span style="color: #0000ff">if</span> (numberToConvert &lt;= MAX_ANALOG_VALUE)
    {
        thousands = numberToConvert / 1000;
        hundreds = numberToConvert / 100;
        <span style="color: #0000ff">if</span> (hundreds &gt;= 10)
        {
            hundreds = 0;
        }
        tens = numberToConvert;
        tens -= ((thousands * 1000) + (hundreds * 100));
        tens /= 10;
        units = numberToConvert;
        units -= ((thousands * 1000) + (hundreds * 100) + (tens * 10));

        strNumber[0] = thousands + <span style="color: #a31515">&#39;0&#39;</span>;
        strNumber[1] = hundreds + <span style="color: #a31515">&#39;0&#39;</span>;
        strNumber[2] = tens + <span style="color: #a31515">&#39;0&#39;</span>;
        strNumber[3] = units + <span style="color: #a31515">&#39;0&#39;</span>;
        strNumber[4] = <span style="color: #a31515">&#39;\0&#39;</span>;
    }
    <span style="color: #0000ff">else</span>
    {
        error = TRUE;
    }
    <span style="color: #0000ff">return</span> !error;
}

<span style="color: #008000">/**</span>
<span style="color: #008000"> * Chequea que el comando a enviar hacia la aplicacion de hardware virtual</span>
<span style="color: #008000"> * sea un comando valido. Por ejemplo, no se puede ejecutar el comando de</span>
<span style="color: #008000"> * escribrir un GPIO en el periferico LCD o no se puede realizar el comando</span>
<span style="color: #008000"> * de leer un analogico de un pin digital.</span>
<span style="color: #008000"> * Para cada comando, chequea que el periferico sea correcto.</span>
<span style="color: #008000"> * @param command comando a enviar a la aplicacion.</span>
<span style="color: #008000"> * @param perMap periferico virtual sobre el cual se ejecutara el comando.</span>
<span style="color: #008000"> * @return 1 si es una combinacion comando/periferico valida, 0 si no lo es.</span>
<span style="color: #008000"> */</span>
<span style="color: #0000ff">static</span> <span style="color: #2b91af">bool_t</span> CheckIfValidCommand (ViHardCommand_t command,
        ViHardPeriph_t perMap)
{
    <span style="color: #2b91af">bool_t</span> isValidCommand = FALSE;
    <span style="color: #0000ff">if</span> (command == VH_GPIO_READ)
    {
        <span style="color: #0000ff">if</span> (perMap == VH_TEC1 || perMap == VH_TEC2 ||
            perMap == VH_TEC3 || perMap == VH_TEC4)
        {
            isValidCommand = TRUE;
        }
        <span style="color: #0000ff">if</span> (perMap == VH_LEDR || perMap == VH_LEDG || perMap == VH_LEDB ||
            perMap == VH_LED1 || perMap == VH_LED2 || perMap == VH_LED3 ||
            perMap == VH_LED4)
        {
            isValidCommand = TRUE;
        }
    }
    <span style="color: #0000ff">else</span> <span style="color: #0000ff">if</span> (command == VH_GPIO_WRITE)
    {
        <span style="color: #0000ff">if</span> (perMap == VH_LEDR || perMap == VH_LEDG || perMap == VH_LEDB ||
            perMap == VH_LED1 || perMap == VH_LED2 || perMap == VH_LED3 ||
            perMap == VH_LED4)
        {
            isValidCommand = TRUE;
        }
    }
    <span style="color: #0000ff">else</span> <span style="color: #0000ff">if</span> (command == VH_ADC_READ)
    {
        <span style="color: #0000ff">if</span> (perMap == VH_ADC_CH1)
        {
            isValidCommand = TRUE;
        }
    }
    <span style="color: #0000ff">else</span> <span style="color: #0000ff">if</span> (command == VH_DAC_WRITE)
    {
        <span style="color: #0000ff">if</span> (perMap == VH_DAC_CH1)
        {
            isValidCommand = TRUE;
        }
    }
    <span style="color: #0000ff">else</span> <span style="color: #0000ff">if</span> (command == VH_LCD_WRITE_BYTE || command == VH_LCD_WRITE_STRING)
    {
        <span style="color: #0000ff">if</span> (perMap == VH_LCD1)
        {
            isValidCommand = TRUE;
        }
    }
    <span style="color: #0000ff">else</span> <span style="color: #0000ff">if</span> (command == VH_7SEG_WRITE)
    {
        <span style="color: #0000ff">if</span> (perMap == VH_7SEG)
        {
            isValidCommand = TRUE;
        }
    }

    <span style="color: #0000ff">if</span> (isValidCommand)
    {
        DelayMs(MS_BETWEEN_COMMANDS);
    }

    <span style="color: #0000ff">return</span> isValidCommand;
}

<span style="color: #008000">/*==================[external functions definition]==========================*/</span>

<span style="color: #008000">/**</span>
<span style="color: #008000"> * Configura el puerto serie por el que se va a comunicar el sistema embebido</span>
<span style="color: #008000"> * con la plataforma de hardware virtual.</span>
<span style="color: #008000"> * Se elige que solo se reciba la velocidad de la uart y no a que uart se va</span>
<span style="color: #008000"> * a conectar ya que el framework de Arduino unicamente recibe como parametro</span>
<span style="color: #008000"> * la velocidad de conexion.</span>
<span style="color: #008000"> * @param baudRate velocidad de transmision.</span>
<span style="color: #008000"> * @return 1 siempre.</span>
<span style="color: #008000"> */</span>
<span style="color: #2b91af">bool_t</span> Vh_BoardConfig (<span style="color: #2b91af">uint32_t</span> baudRate)
{
    <span style="color: #008000">// Se calcula el tiempo entre lecturas dependiendo baudrate y se agrega 10%</span>
    UsBetweenReads = round((1000000 / baudRate) + ((1000000 / baudRate) * 0.1));
    UART_CONFIG(baudRate);

    <span style="color: #0000ff">return</span> TRUE;
}

<span style="color: #008000">/**</span>
<span style="color: #008000"> * Escribe un estado logico en un pin virtual.</span>
<span style="color: #008000"> * @param virtualGpioPin pin virtual a escribir.</span>
<span style="color: #008000"> * @param pinState estado logico a enviar.</span>
<span style="color: #008000"> */</span>
<span style="color: #2b91af">void</span> Vh_GpioWrite (ViHardPeriph_t gpioPin, <span style="color: #2b91af">bool_t</span> pinState)
{
    <span style="color: #2b91af">char</span> stringCommand[10];

    <span style="color: #0000ff">if</span> (CheckIfValidCommand(VH_GPIO_WRITE, gpioPin))
    {
        stringCommand[0] = COMMAND_INIT;
        stringCommand[1] = VH_GPIO_WRITE;
        stringCommand[2] = COMMAND_SEPARATOR;
        stringCommand[3] = gpioPin;
        stringCommand[4] = COMMAND_SEPARATOR;
        stringCommand[5] = pinState == TRUE ? VH_GPIO_HIGH : VH_GPIO_LOW;
        stringCommand[6] = COMMAND_END;
        stringCommand[7] = <span style="color: #a31515">&#39;\n&#39;</span>;
        stringCommand[8] = <span style="color: #a31515">&#39;\0&#39;</span>;

        UartWriteString(stringCommand);
    }
}

<span style="color: #008000">/**</span>
<span style="color: #008000"> * Lee el estado logico de un pin virtual.</span>
<span style="color: #008000"> * @param virtualGpioPin pin virtual a leer.</span>
<span style="color: #008000"> * @return estado logico leido.</span>
<span style="color: #008000"> */</span>
<span style="color: #2b91af">bool_t</span> Vh_GpioRead (ViHardPeriph_t gpioPin)
{
    <span style="color: #2b91af">char</span> stringCommand[10];
    <span style="color: #2b91af">bool_t</span> pinState = TRUE;
    <span style="color: #2b91af">uint8_t</span> dataSerial = 0;
    <span style="color: #2b91af">uint16_t</span> counter = 0;
    <span style="color: #2b91af">uint8_t</span> i = 0;
    <span style="color: #2b91af">bool_t</span> flagCommandInit = FALSE;

    <span style="color: #0000ff">if</span> (CheckIfValidCommand(VH_GPIO_READ, gpioPin))
    {
        stringCommand[0] = COMMAND_INIT;
        stringCommand[1] = VH_GPIO_READ;
        stringCommand[2] = COMMAND_SEPARATOR;
        stringCommand[3] = gpioPin;
        stringCommand[4] = COMMAND_SEPARATOR;
        stringCommand[5] = VH_COMM_REQUEST;
        stringCommand[6] = COMMAND_END;
        stringCommand[7] = <span style="color: #a31515">&#39;\n&#39;</span>;
        stringCommand[8] = <span style="color: #a31515">&#39;\0&#39;</span>;

        UartWriteString(stringCommand);

        <span style="color: #008000">// limpia el buffer</span>
        <span style="color: #0000ff">for</span> (i = 0; i &lt; 10; i++)
        {
            stringCommand[i] = 0;
        }
        i = 0;

        <span style="color: #008000">// Espera a recibir data por un tiempo determinado</span>
        <span style="color: #0000ff">while</span> (++counter &lt; 1000 &amp;&amp; i &lt; 10)
        {
            <span style="color: #0000ff">if</span> ((dataSerial = UartReadByte()) != 0)
            {
                <span style="color: #0000ff">if</span> (dataSerial == COMMAND_INIT)
                {
                    flagCommandInit = TRUE;
                }
                <span style="color: #0000ff">if</span> (flagCommandInit)
                {
                    stringCommand[i] = dataSerial;
                    <span style="color: #0000ff">if</span> (stringCommand[i] == <span style="color: #a31515">&#39;}&#39;</span>)
                    {
                        <span style="color: #0000ff">break</span>;
                    }
                    i++;
                }
            }
        }

        <span style="color: #008000">// chequea si salio por timeout</span>
        <span style="color: #0000ff">if</span> (counter &lt; 1000)
        {
            <span style="color: #008000">// chequea que todos lo que haya llegado</span>
            <span style="color: #008000">// sea una respuesta correcta</span>
            <span style="color: #0000ff">if</span> (stringCommand[0] == COMMAND_INIT &amp;&amp;
                stringCommand[1] == VH_GPIO_READ &amp;&amp;
                stringCommand[2] == COMMAND_SEPARATOR &amp;&amp;
                stringCommand[4] == COMMAND_SEPARATOR &amp;&amp;
                stringCommand[5] == VH_COMM_RESPONSE &amp;&amp;
                stringCommand[6] == COMMAND_SEPARATOR &amp;&amp;
               (stringCommand[7] == VH_GPIO_LOW ||
                stringCommand[7] == VH_GPIO_HIGH))
            {
                pinState = stringCommand[7] - <span style="color: #a31515">&#39;0&#39;</span>;
            }
        }
    }

    <span style="color: #0000ff">return</span> pinState;
}

<span style="color: #008000">/**</span>
<span style="color: #008000"> * Invierte el estado logico de un pin.</span>
<span style="color: #008000"> * Notar que para que esta accion se realice, el pin a invertir su estado</span>
<span style="color: #008000"> * debe ser un pin de salida.</span>
<span style="color: #008000"> * @param virtualGpioPin pin a invertir el estado logico.</span>
<span style="color: #008000"> */</span>
<span style="color: #2b91af">void</span> Vh_GpioToggle (ViHardPeriph_t gpioPin)
{
    Vh_GpioWrite(gpioPin, !Vh_GpioRead(gpioPin));
}

<span style="color: #008000">/**</span>
<span style="color: #008000"> * Realiza una lectura sobre un pin analogico.</span>
<span style="color: #008000"> * La conversion ADC tiene una resolucion de 10 bits, por lo que, sus</span>
<span style="color: #008000"> * valores estan comprendidos entre 0 y 1023.</span>
<span style="color: #008000"> * @param virtualAdcPin pin analogico virtual a leer.</span>
<span style="color: #008000"> * @return valor analogico leido.</span>
<span style="color: #008000"> */</span>
<span style="color: #2b91af">uint16_t</span> Vh_AdcRead (ViHardPeriph_t adcChannel)
{
    <span style="color: #2b91af">char</span> stringCommand[15];
    <span style="color: #0000ff">static</span> <span style="color: #2b91af">uint16_t</span> adcValue = 0;
    <span style="color: #2b91af">uint8_t</span> dataSerial = 0;
    <span style="color: #2b91af">uint16_t</span> counter = 0;
    <span style="color: #2b91af">uint8_t</span> i = 0;
    <span style="color: #2b91af">bool_t</span> flagCommandInit = FALSE;

    <span style="color: #0000ff">if</span> (CheckIfValidCommand(VH_ADC_READ, adcChannel))
    {

        stringCommand[0] = COMMAND_INIT;
        stringCommand[1] = VH_ADC_READ;
        stringCommand[2] = COMMAND_SEPARATOR;
        stringCommand[3] = adcChannel;
        stringCommand[4] = COMMAND_SEPARATOR;
        stringCommand[5] = VH_COMM_REQUEST;
        stringCommand[6] = COMMAND_END;
        stringCommand[7] = <span style="color: #a31515">&#39;\n&#39;</span>;
        stringCommand[8] = <span style="color: #a31515">&#39;\0&#39;</span>;

        UartWriteString(stringCommand);

        <span style="color: #008000">// limpia el buffer</span>
        <span style="color: #0000ff">for</span> (i = 0; i &lt; 15; i++)
        {
            stringCommand[i] = 0;
        }
        i = 0;

        <span style="color: #008000">// Espera a recibir data por un tiempo determinado</span>
        <span style="color: #0000ff">while</span> (++counter &lt; 1000 &amp;&amp; i &lt; 15)
        {
            <span style="color: #0000ff">if</span> ((dataSerial = UartReadByte()) != 0)
            {
                <span style="color: #0000ff">if</span> (dataSerial == COMMAND_INIT)
                {
                    flagCommandInit = TRUE;
                }
                <span style="color: #0000ff">if</span> (flagCommandInit)
                {
                    stringCommand[i] = dataSerial;
                    <span style="color: #0000ff">if</span> (stringCommand[i] == <span style="color: #a31515">&#39;}&#39;</span>)
                    {
                        <span style="color: #0000ff">break</span>;
                    }
                    i++;
                }
            }
        }

        <span style="color: #008000">// chequea si salio por timeout</span>
        <span style="color: #0000ff">if</span> (i == 11 &amp;&amp; counter &lt; 1000)
        {
            <span style="color: #008000">// chequea que todos lo que haya llegado</span>
            <span style="color: #008000">// sea una respuesta correcta</span>
            <span style="color: #0000ff">if</span> (stringCommand[0] == COMMAND_INIT
                    &amp;&amp; stringCommand[1] == VH_ADC_READ&amp;&amp;
                    stringCommand[2] == COMMAND_SEPARATOR &amp;&amp;
                    stringCommand[3] == adcChannel &amp;&amp;
                    stringCommand[4] == COMMAND_SEPARATOR &amp;&amp;
                    stringCommand[5] == VH_COMM_RESPONSE &amp;&amp;
                    stringCommand[6] == COMMAND_SEPARATOR &amp;&amp;
                    stringCommand[11] == COMMAND_END)
            {
                adcValue = 0;
                <span style="color: #008000">// unidades de mil</span>
                adcValue += (stringCommand[7] - <span style="color: #a31515">&#39;0&#39;</span>) * 1000;
                <span style="color: #008000">// centenas</span>
                adcValue += (stringCommand[8] - <span style="color: #a31515">&#39;0&#39;</span>) * 100;
                <span style="color: #008000">// decenas</span>
                adcValue += (stringCommand[9] - <span style="color: #a31515">&#39;0&#39;</span>) * 10;
                <span style="color: #008000">// unidades</span>
                adcValue += (stringCommand[10] - <span style="color: #a31515">&#39;0&#39;</span>);

                <span style="color: #0000ff">if</span> (adcValue &gt; MAX_ANALOG_VALUE)
                {
                    adcValue = MAX_ANALOG_VALUE;
                }
                <span style="color: #0000ff">else</span> <span style="color: #0000ff">if</span> (adcValue &lt; 0)
                {
                    adcValue = 0;
                }
            }
        }
    }

    <span style="color: #0000ff">return</span> adcValue;
}

<span style="color: #008000">/**</span>
<span style="color: #008000"> * Escribe un valor analogico sobre una salida analogica.</span>
<span style="color: #008000"> * El valor a escribir es de 10 bits, por lo que, sus</span>
<span style="color: #008000"> * valores estan comprendidos entre 0 y 1023.</span>
<span style="color: #008000"> * @param dacChannel pin analogico a escribir.</span>
<span style="color: #008000"> * @param dacValue valor de 10 bits a escribir.</span>
<span style="color: #008000"> */</span>
<span style="color: #2b91af">void</span> Vh_DacWrite (ViHardPeriph_t dacChannel, <span style="color: #2b91af">uint16_t</span> dacValue)
{
    <span style="color: #2b91af">char</span> stringCommand[15];
    <span style="color: #2b91af">char</span> analogString[5];

    <span style="color: #0000ff">if</span> (CheckIfValidCommand(VH_DAC_WRITE, dacChannel))
    {
        <span style="color: #0000ff">if</span> (dacValue &gt; MAX_ANALOG_VALUE)
        {
            dacValue = MAX_ANALOG_VALUE;
        }
        <span style="color: #0000ff">else</span> <span style="color: #0000ff">if</span> (dacValue &lt; 0)
        {
            dacValue = 0;
        }

        <span style="color: #0000ff">if</span> (AnalogValueToString(dacValue, analogString))
        {
            stringCommand[0]  = COMMAND_INIT;
            stringCommand[1]  = VH_DAC_WRITE;
            stringCommand[2]  = COMMAND_SEPARATOR;
            stringCommand[3]  = dacChannel;
            stringCommand[4]  = COMMAND_SEPARATOR;
            stringCommand[5]  = analogString[0];
            stringCommand[6]  = analogString[1];
            stringCommand[7]  = analogString[2];
            stringCommand[8]  = analogString[3];
            stringCommand[9]  = COMMAND_END;
            stringCommand[10] = <span style="color: #a31515">&#39;\n&#39;</span>;
            stringCommand[11] = <span style="color: #a31515">&#39;\0&#39;</span>;

            UartWriteString(stringCommand);
        }
    }
}

<span style="color: #008000">/**</span>
<span style="color: #008000"> * Escribe un caracter ASCII sobre el periferico display 7 segmentos.</span>
<span style="color: #008000"> * A diferencia de un display 7 segmentos real, este display, por el tipo</span>
<span style="color: #008000"> * de letra elegido, puede escribir cualquier caracter ASCII sobre el display</span>
<span style="color: #008000"> * a diferencia de uno tradicional que puede escribir del 0-9 y A-F.</span>
<span style="color: #008000"> * @param display periferico del display 7 segmentos.</span>
<span style="color: #008000"> * @param valueToShow caracter ASCII a mostrar sobre el display.</span>
<span style="color: #008000"> */</span>
<span style="color: #2b91af">void</span> Vh_7SegmentsWrite (ViHardPeriph_t display7Segs, <span style="color: #2b91af">uint8_t</span> asciiToShow)
{
    <span style="color: #2b91af">char</span> stringCommand[10];

    <span style="color: #0000ff">if</span> (CheckIfValidCommand(VH_7SEG_WRITE, display7Segs))
    {
        stringCommand[0] = COMMAND_INIT;
        stringCommand[1] = VH_7SEG_WRITE;
        stringCommand[2] = COMMAND_SEPARATOR;
        stringCommand[3] = display7Segs;
        stringCommand[4] = COMMAND_SEPARATOR;
        stringCommand[5] = asciiToShow;
        stringCommand[6] = COMMAND_END;
        stringCommand[7] = <span style="color: #a31515">&#39;\n&#39;</span>;
        stringCommand[8] = <span style="color: #a31515">&#39;\0&#39;</span>;

        UartWriteString(stringCommand);
    }
}

<span style="color: #008000">/**</span>
<span style="color: #008000"> * Escribe un texto sobre el periferico display LCD.</span>
<span style="color: #008000"> * Como en el caso de un display LCD real, se puede seleccionar la linea</span>
<span style="color: #008000"> * sobre la cual escribir el texto.</span>
<span style="color: #008000"> * @param display periferico del display lcd sobre el cual escribir.</span>
<span style="color: #008000"> * @param lcdLine la linea sobre la cual escribir el mensaje, los posibles</span>
<span style="color: #008000"> * valores de la lineas son:</span>
<span style="color: #008000"> * --- LCD_LINE_ALL: escribe un mensaje multilinea.</span>
<span style="color: #008000"> * --- LCD_LINE_FIRST: escribe en la primer linea.</span>
<span style="color: #008000"> * --- LCD_LINE_SECOND: escribe en la segunda linea.</span>
<span style="color: #008000"> * --- LCD_LINE_THIRD: escribe en la tercer linea.</span>
<span style="color: #008000"> * @param stringToWrite cadena a escribir</span>
<span style="color: #008000"> */</span>
<span style="color: #2b91af">void</span> Vh_LcdWriteString (ViHardPeriph_t displayLcd, LcdLine_t line, <span style="color: #2b91af">char</span> * str)
{
    <span style="color: #2b91af">uint8_t</span> i = 0;
    <span style="color: #2b91af">uint8_t</span> lenght = 0;
    <span style="color: #2b91af">char</span> stringCommand[70];

    <span style="color: #0000ff">if</span> (CheckIfValidCommand(VH_LCD_WRITE_STRING, displayLcd))
    {
        <span style="color: #0000ff">for</span> (lenght = 0; str[lenght] != <span style="color: #a31515">&#39;\0&#39;</span>; lenght++);

        stringCommand[0] = COMMAND_INIT;
        stringCommand[1] = VH_LCD_WRITE_STRING;
        stringCommand[2] = COMMAND_SEPARATOR;
        stringCommand[3] = displayLcd;
        stringCommand[4] = COMMAND_SEPARATOR;
        stringCommand[5] = line;
        stringCommand[6] = COMMAND_SEPARATOR;

        <span style="color: #0000ff">for</span> (i = 0; i &lt; lenght; i++)
        {
            stringCommand[i + 7] = str[i];
        }

        stringCommand[7 + lenght] = COMMAND_END;
        stringCommand[8 + lenght] = <span style="color: #a31515">&#39;\n&#39;</span>;
        stringCommand[9 + lenght] = <span style="color: #a31515">&#39;\0&#39;</span>;

        UartWriteString(stringCommand);
    }
}

<span style="color: #008000">/*==================[end of file]============================================*/</span>
</pre></td></tr></table></div>
